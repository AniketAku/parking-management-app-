// Report Export Service with Proper Filename Conventions

import { format } from 'date-fns'
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import * as XLSX from 'xlsx'

// Create extended jsPDF type
type ExtendedJsPDF = jsPDF & {
  lastAutoTable?: {
    finalY: number
  }
}
import type {
  ReportGenerationResponse,
  ExportConfig,
  ExportResult,
  ReportType,
  DateBoundary,
  DailyReportContent,
  WeeklyReportContent,
  MonthlyReportContent,
  CustomReportContent
} from '../types/reports'

interface ExtendedJsPDF extends jsPDF {
  autoTable: any
}

class ReportExportService {
  /**
   * === FILENAME CONVENTIONS ===
   */
  generateFileName(reportType: ReportType, dateRange: DateBoundary, exportFormat: string, customName?: string): string {
    if (customName) {
      return `${customName}.${exportFormat}`
    }

    const startDate = format(dateRange.startDate, 'yyyy-MM-dd')
    const endDate = format(dateRange.endDate, 'yyyy-MM-dd')

    switch (reportType) {
      case 'daily':
        return `Parking_Report_Daily_${startDate}.${exportFormat}`

      case 'weekly':
        const weekNumber = format(dateRange.startDate, 'ww')
        const year = format(dateRange.startDate, 'yyyy')
        return `Parking_Report_Weekly_${year}-${weekNumber.padStart(2, '0')}.${exportFormat}`

      case 'monthly':
        const monthYear = format(dateRange.startDate, 'yyyy-MM')
        return `Parking_Report_Monthly_${monthYear}.${exportFormat}`

      case 'custom':
        return `Parking_Report_Custom_${startDate}_${endDate}.${exportFormat}`

      default:
        return `Parking_Report_${startDate}_${endDate}.${exportFormat}`
    }
  }

  /**
   * === MAIN EXPORT METHOD ===
   */
  async exportReport(
    report: ReportGenerationResponse,
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      const fileName = this.generateFileName(
        report.reportType,
        report.dateRange,
        config.format,
        config.customFileName
      )

      switch (config.format) {
        case 'pdf':
          return await this.exportToPDF(report, config, fileName)
        case 'excel':
          return await this.exportToExcel(report, config, fileName)
        case 'csv':
          return await this.exportToCSV(report, config, fileName)
        default:
          throw new Error(`Unsupported export format: ${config.format}`)
      }
    } catch (error) {
      return {
        success: false,
        fileName: '',
        error: error instanceof Error ? error.message : 'Export failed'
      }
    }
  }

  /**
   * === PDF EXPORT IMPLEMENTATION ===
   */
  private async exportToPDF(
    report: ReportGenerationResponse,
    config: ExportConfig,
    fileName: string
  ): Promise<ExportResult> {
    const doc = new jsPDF() as ExtendedJsPDF

    // Document metadata
    doc.setProperties({
      title: `Parking Report - ${report.reportType}`,
      subject: `Parking Management Report`,
      author: 'Parking Management System',
      creator: 'Parking Management System'
    })

    let yPosition = 20

    // Header
    doc.setFontSize(20)
    doc.setFont(undefined, 'bold')
    doc.text(`${report.reportType.toUpperCase()} PARKING REPORT`, 20, yPosition)
    yPosition += 10

    doc.setFontSize(12)
    doc.setFont(undefined, 'normal')
    doc.text(
      `Period: ${format(report.dateRange.startDate, 'MMMM d, yyyy')} - ${format(report.dateRange.endDate, 'MMMM d, yyyy')}`,
      20,
      yPosition
    )
    yPosition += 10

    doc.text(`Generated: ${format(report.generatedAt, 'MMMM d, yyyy \'at\' h:mm a')}`, 20, yPosition)
    yPosition += 20

    // Report content based on type
    switch (report.reportType) {
      case 'daily':
        yPosition = this.addDailyReportContent(doc, report.data as DailyReportContent, yPosition, config)
        break
      case 'weekly':
        yPosition = this.addWeeklyReportContent(doc, report.data as WeeklyReportContent, yPosition, config)
        break
      case 'monthly':
        yPosition = this.addMonthlyReportContent(doc, report.data as MonthlyReportContent, yPosition, config)
        break
      case 'custom':
        yPosition = this.addCustomReportContent(doc, report.data as CustomReportContent, yPosition, config)
        break
    }

    // Footer with generation details
    const pageCount = doc.getNumberOfPages()
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i)
      doc.setFontSize(8)
      doc.text(
        `Generated by Parking Management System - Page ${i} of ${pageCount}`,
        20,
        doc.internal.pageSize.height - 10
      )
    }

    // Generate blob and download link
    const pdfBlob = doc.output('blob')
    const downloadLink = URL.createObjectURL(pdfBlob)

    return {
      success: true,
      fileName,
      downloadLink
    }
  }

  private addDailyReportContent(
    doc: ExtendedJsPDF,
    data: DailyReportContent,
    yPosition: number,
    config: ExportConfig
  ): number {
    // Summary section
    doc.setFontSize(14)
    doc.setFont(undefined, 'bold')
    doc.text('Daily Summary', 20, yPosition)
    yPosition += 15

    const summaryData = [
      ['Total Sessions', (data.totalSessions ?? 0).toString()],
      ['Active Sessions', (data.activeSessions ?? 0).toString()],
      ['Completed Sessions', (data.completedSessions ?? 0).toString()],
      ['Revenue', `$${(data.revenue ?? 0).toFixed(2)}`],
      ['Expenses', `$${(data.expenses ?? 0).toFixed(2)}`],
      ['Net Income', `$${(data.netIncome ?? 0).toFixed(2)}`]
    ]

    autoTable(doc, {
      startY: yPosition,
      head: [['Metric', 'Value']],
      body: summaryData,
      theme: 'grid',
      styles: { fontSize: 10 }
    })

    yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20

    // Hourly breakdown if enabled
    if (config.includeHourlyBreakdown && data.hourlyBreakdown?.length > 0) {
      if (yPosition > 200) {
        doc.addPage()
        yPosition = 20
      }

      doc.setFontSize(14)
      doc.setFont(undefined, 'bold')
      doc.text('Hourly Breakdown', 20, yPosition)
      yPosition += 15

      const hourlyData = data.hourlyBreakdown.map(hour => [
        `${hour?.hour ?? 0}:00`,
        (hour?.entries ?? 0).toString(),
        (hour?.exits ?? 0).toString(),
        `$${(hour?.revenue ?? 0).toFixed(2)}`,
        (hour?.occupancy ?? 0).toString()
      ])

      autoTable(doc, {
        startY: yPosition,
        head: [['Hour', 'Entries', 'Exits', 'Revenue', 'Occupancy']],
        body: hourlyData,
        theme: 'grid',
        styles: { fontSize: 8 }
      })

      yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20
    }

    // Vehicle type breakdown
    if (data.vehicleTypeBreakdown?.length > 0) {
      if (yPosition > 200) {
        doc.addPage()
        yPosition = 20
      }

      doc.setFontSize(14)
      doc.setFont(undefined, 'bold')
      doc.text('Vehicle Type Breakdown', 20, yPosition)
      yPosition += 15

      const vehicleData = data.vehicleTypeBreakdown.map(type => [
        type?.vehicleType ?? 'Unknown',
        (type?.count ?? 0).toString(),
        `${(type?.percentage ?? 0).toFixed(1)}%`,
        `$${(type?.revenue ?? 0).toFixed(2)}`,
        `${(type?.averageStayDuration ?? 0).toFixed(1)}h`
      ])

      autoTable(doc, {
        startY: yPosition,
        head: [['Vehicle Type', 'Count', 'Percentage', 'Revenue', 'Avg Stay']],
        body: vehicleData,
        theme: 'grid',
        styles: { fontSize: 10 }
      })

      yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20
    }

    return yPosition
  }

  private addWeeklyReportContent(
    doc: ExtendedJsPDF,
    data: WeeklyReportContent,
    yPosition: number,
    config: ExportConfig
  ): number {
    // Weekly summary
    doc.setFontSize(14)
    doc.setFont(undefined, 'bold')
    doc.text('Weekly Summary', 20, yPosition)
    yPosition += 15

    const summaryData = [
      ['Total Sessions', (data.weeklyTotals?.totalSessions ?? 0).toString()],
      ['Total Revenue', `$${(data.weeklyTotals?.totalRevenue ?? 0).toFixed(2)}`],
      ['Total Expenses', `$${(data.weeklyTotals?.totalExpenses ?? 0).toFixed(2)}`],
      ['Net Income', `$${(data.weeklyTotals?.netIncome ?? 0).toFixed(2)}`],
      ['Average Occupancy', `${(data.weeklyTotals?.averageOccupancy ?? 0).toFixed(1)}%`],
      ['Avg Sessions/Day', (data.weeklyAverages?.avgSessionsPerDay ?? 0).toFixed(1)],
      ['Avg Revenue/Day', `$${(data.weeklyAverages?.avgRevenuePerDay ?? 0).toFixed(2)}`]
    ]

    autoTable(doc, {
      startY: yPosition,
      head: [['Metric', 'Value']],
      body: summaryData,
      theme: 'grid',
      styles: { fontSize: 10 }
    })

    yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20

    // Daily breakdown if enabled
    if (config.includeDailyBreakdown && data.dailyBreakdown?.length > 0) {
      if (yPosition > 180) {
        doc.addPage()
        yPosition = 20
      }

      doc.setFontSize(14)
      doc.setFont(undefined, 'bold')
      doc.text('Daily Breakdown', 20, yPosition)
      yPosition += 15

      const dailyData = data.dailyBreakdown.map(day => [
        format(new Date(day?.date ?? new Date()), 'EEE, MMM d'),
        (day?.totalSessions ?? 0).toString(),
        (day?.activeSessions ?? 0).toString(),
        (day?.completedSessions ?? 0).toString(),
        `$${(day?.revenue ?? 0).toFixed(2)}`,
        `$${(day?.netIncome ?? 0).toFixed(2)}`
      ])

      autoTable(doc, {
        startY: yPosition,
        head: [['Date', 'Total', 'Active', 'Completed', 'Revenue', 'Net Income']],
        body: dailyData,
        theme: 'grid',
        styles: { fontSize: 8 }
      })

      yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20
    }

    return yPosition
  }

  private addMonthlyReportContent(
    doc: ExtendedJsPDF,
    data: MonthlyReportContent,
    yPosition: number,
    config: ExportConfig
  ): number {
    // Monthly summary
    doc.setFontSize(14)
    doc.setFont(undefined, 'bold')
    doc.text('Monthly Summary', 20, yPosition)
    yPosition += 15

    const summaryData = [
      ['Total Sessions', (data.monthlyTotals?.totalSessions ?? 0).toString()],
      ['Total Revenue', `$${(data.monthlyTotals?.totalRevenue ?? 0).toFixed(2)}`],
      ['Total Expenses', `$${(data.monthlyTotals?.totalExpenses ?? 0).toFixed(2)}`],
      ['Net Income', `$${(data.monthlyTotals?.netIncome ?? 0).toFixed(2)}`],
      ['Working Days', (data.monthlyTotals?.totalWorkingDays ?? 0).toString()]
    ]

    autoTable(doc, {
      startY: yPosition,
      head: [['Metric', 'Value']],
      body: summaryData,
      theme: 'grid',
      styles: { fontSize: 10 }
    })

    yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20

    // Best performing days
    if (data.bestPerformingDays?.length > 0) {
      if (yPosition > 200) {
        doc.addPage()
        yPosition = 20
      }

      doc.setFontSize(14)
      doc.setFont(undefined, 'bold')
      doc.text('Best Performing Days', 20, yPosition)
      yPosition += 15

      const bestDaysData = data.bestPerformingDays.map(day => [
        format(new Date(day?.date ?? new Date()), 'MMMM d, yyyy'),
        (day?.sessions ?? 0).toString(),
        `$${(day?.revenue ?? 0).toFixed(2)}`,
        `${(day?.occupancyRate ?? 0).toFixed(1)}%`
      ])

      autoTable(doc, {
        startY: yPosition,
        head: [['Date', 'Sessions', 'Revenue', 'Occupancy']],
        body: bestDaysData,
        theme: 'grid',
        styles: { fontSize: 10 }
      })

      yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20
    }

    return yPosition
  }

  private addCustomReportContent(
    doc: ExtendedJsPDF,
    data: CustomReportContent,
    yPosition: number,
    config: ExportConfig
  ): number {
    // Custom report summary
    doc.setFontSize(14)
    doc.setFont(undefined, 'bold')
    doc.text('Report Summary', 20, yPosition)
    yPosition += 15

    const summaryData = [
      ['Total Days', (data.totalDays ?? 0).toString()],
      ['Total Sessions', (data.summary?.totalSessions ?? 0).toString()],
      ['Total Revenue', `$${(data.summary?.totalRevenue ?? 0).toFixed(2)}`],
      ['Net Income', `$${(data.summary?.netIncome ?? 0).toFixed(2)}`],
      ['Avg Stay Duration', `${(data.summary?.averageStayDuration ?? 0).toFixed(1)}h`],
      ['Avg Revenue/Session', `$${(data.summary?.averageRevenuePerSession ?? 0).toFixed(2)}`],
      ['Top Vehicle Type', data.summary?.topVehicleType ?? 'N/A'],
      ['Top Payment Method', data.summary?.topPaymentMethod ?? 'N/A']
    ]

    autoTable(doc, {
      startY: yPosition,
      head: [['Metric', 'Value']],
      body: summaryData,
      theme: 'grid',
      styles: { fontSize: 10 }
    })

    yPosition = (doc as ExtendedJsPDF).lastAutoTable!.finalY + 20

    return yPosition
  }

  /**
   * === EXCEL EXPORT IMPLEMENTATION ===
   */
  private async exportToExcel(
    report: ReportGenerationResponse,
    config: ExportConfig,
    fileName: string
  ): Promise<ExportResult> {
    const workbook = XLSX.utils.book_new()

    // Summary sheet
    const summaryData = this.prepareSummaryDataForExcel(report)
    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

    // Report-specific sheets
    switch (report.reportType) {
      case 'daily':
        this.addDailyExcelSheets(workbook, report.data as DailyReportContent, config)
        break
      case 'weekly':
        this.addWeeklyExcelSheets(workbook, report.data as WeeklyReportContent, config)
        break
      case 'monthly':
        this.addMonthlyExcelSheets(workbook, report.data as MonthlyReportContent, config)
        break
      case 'custom':
        this.addCustomExcelSheets(workbook, report.data as CustomReportContent, config)
        break
    }

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' })
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' })
    const downloadLink = URL.createObjectURL(blob)

    return {
      success: true,
      fileName,
      downloadLink
    }
  }

  private prepareSummaryDataForExcel(report: ReportGenerationResponse): any[][] {
    const data = report.data as any

    return [
      ['Parking Management Report'],
      [''],
      ['Report Type', report.reportType.toUpperCase()],
      ['Period', `${format(report.dateRange.startDate, 'MMMM d, yyyy')} - ${format(report.dateRange.endDate, 'MMMM d, yyyy')}`],
      ['Generated', format(report.generatedAt, 'MMMM d, yyyy \'at\' h:mm a')],
      ['Processing Time', `${report.metadata.processingTimeMs}ms`],
      ['Data Source', report.metadata.dataSource],
      [''],
      ['Summary Metrics'],
      ['Total Sessions', data.totalSessions || data.summary?.totalSessions || 0],
      ['Revenue', data.revenue || data.summary?.totalRevenue || 0],
      ['Net Income', data.netIncome || data.summary?.netIncome || 0]
    ]
  }

  private addDailyExcelSheets(workbook: XLSX.WorkBook, data: DailyReportContent, config: ExportConfig) {
    // Hourly breakdown sheet
    if (config.includeHourlyBreakdown && data.hourlyBreakdown?.length > 0) {
      const hourlyData = [
        ['Hour', 'Entries', 'Exits', 'Revenue', 'Occupancy'],
        ...data.hourlyBreakdown.map(hour => [
          `${hour.hour}:00`,
          hour.entries,
          hour.exits,
          hour.revenue,
          hour.occupancy
        ])
      ]
      const hourlySheet = XLSX.utils.aoa_to_sheet(hourlyData)
      XLSX.utils.book_append_sheet(workbook, hourlySheet, 'Hourly Breakdown')
    }

    // Vehicle type breakdown
    if (data.vehicleTypeBreakdown?.length > 0) {
      const vehicleData = [
        ['Vehicle Type', 'Count', 'Percentage', 'Revenue', 'Avg Stay Duration'],
        ...data.vehicleTypeBreakdown.map(type => [
          type.vehicleType,
          type.count,
          type.percentage,
          type.revenue,
          type.averageStayDuration
        ])
      ]
      const vehicleSheet = XLSX.utils.aoa_to_sheet(vehicleData)
      XLSX.utils.book_append_sheet(workbook, vehicleSheet, 'Vehicle Types')
    }

    // Payment method breakdown
    if (data.paymentMethodBreakdown?.length > 0) {
      const paymentData = [
        ['Payment Method', 'Count', 'Amount', 'Percentage'],
        ...data.paymentMethodBreakdown.map(method => [
          method.paymentMethod,
          method.count,
          method.amount,
          method.percentage
        ])
      ]
      const paymentSheet = XLSX.utils.aoa_to_sheet(paymentData)
      XLSX.utils.book_append_sheet(workbook, paymentSheet, 'Payment Methods')
    }
  }

  private addWeeklyExcelSheets(workbook: XLSX.WorkBook, data: WeeklyReportContent, config: ExportConfig) {
    // Daily breakdown sheet
    if (config.includeDailyBreakdown && data.dailyBreakdown?.length > 0) {
      const dailyData = [
        ['Date', 'Total Sessions', 'Active Sessions', 'Completed Sessions', 'Revenue', 'Expenses', 'Net Income'],
        ...data.dailyBreakdown.map(day => [
          day.date,
          day.totalSessions,
          day.activeSessions,
          day.completedSessions,
          day.revenue,
          day.expenses,
          day.netIncome
        ])
      ]
      const dailySheet = XLSX.utils.aoa_to_sheet(dailyData)
      XLSX.utils.book_append_sheet(workbook, dailySheet, 'Daily Breakdown')
    }

    // Weekly totals and averages
    const weeklyData = [
      ['Weekly Totals & Averages'],
      [''],
      ['Metric', 'Value'],
      ['Total Sessions', data.weeklyTotals.totalSessions],
      ['Total Revenue', data.weeklyTotals.totalRevenue],
      ['Total Expenses', data.weeklyTotals.totalExpenses],
      ['Net Income', data.weeklyTotals.netIncome],
      ['Average Occupancy', data.weeklyTotals.averageOccupancy],
      [''],
      ['Averages'],
      ['Avg Sessions per Day', data.weeklyAverages.avgSessionsPerDay],
      ['Avg Revenue per Day', data.weeklyAverages.avgRevenuePerDay],
      ['Avg Stay Duration', data.weeklyAverages.avgStayDuration],
      ['Avg Revenue per Session', data.weeklyAverages.avgRevenuePerSession]
    ]
    const weeklySheet = XLSX.utils.aoa_to_sheet(weeklyData)
    XLSX.utils.book_append_sheet(workbook, weeklySheet, 'Weekly Analysis')
  }

  private addMonthlyExcelSheets(workbook: XLSX.WorkBook, data: MonthlyReportContent, config: ExportConfig) {
    // Weekly breakdown sheet
    if (config.includeWeeklyBreakdown && data.weeklyBreakdown?.length > 0) {
      const weeklyData = [
        ['Week Start', 'Week End', 'Total Sessions', 'Total Revenue', 'Net Income'],
        ...data.weeklyBreakdown.map(week => [
          week.weekStart,
          week.weekEnd,
          week.weeklyTotals.totalSessions,
          week.weeklyTotals.totalRevenue,
          week.weeklyTotals.netIncome
        ])
      ]
      const weeklySheet = XLSX.utils.aoa_to_sheet(weeklyData)
      XLSX.utils.book_append_sheet(workbook, weeklySheet, 'Weekly Breakdown')
    }

    // Best/worst performing days
    if (data.bestPerformingDays?.length > 0) {
      const performanceData = [
        ['Best Performing Days'],
        ['Date', 'Sessions', 'Revenue', 'Occupancy Rate'],
        ...data.bestPerformingDays.map(day => [
          day.date,
          day.sessions,
          day.revenue,
          day.occupancyRate
        ]),
        [''],
        ['Worst Performing Days'],
        ['Date', 'Sessions', 'Revenue', 'Occupancy Rate'],
        ...data.worstPerformingDays.map(day => [
          day.date,
          day.sessions,
          day.revenue,
          day.occupancyRate
        ])
      ]
      const performanceSheet = XLSX.utils.aoa_to_sheet(performanceData)
      XLSX.utils.book_append_sheet(workbook, performanceSheet, 'Performance Analysis')
    }
  }

  private addCustomExcelSheets(workbook: XLSX.WorkBook, data: CustomReportContent, config: ExportConfig) {
    // Summary analysis
    const summaryData = [
      ['Custom Report Analysis'],
      [''],
      ['Period', `${data.startDate} to ${data.endDate}`],
      ['Total Days', data.totalDays],
      [''],
      ['Summary'],
      ['Total Sessions', data.summary.totalSessions],
      ['Total Revenue', data.summary.totalRevenue],
      ['Total Expenses', data.summary.totalExpenses],
      ['Net Income', data.summary.netIncome],
      ['Average Stay Duration', data.summary.averageStayDuration],
      ['Average Revenue per Session', data.summary.averageRevenuePerSession],
      ['Occupancy Rate', data.summary.occupancyRate],
      ['Top Vehicle Type', data.summary.topVehicleType],
      ['Top Payment Method', data.summary.topPaymentMethod]
    ]
    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Analysis')
  }

  /**
   * === CSV EXPORT IMPLEMENTATION ===
   */
  private async exportToCSV(
    report: ReportGenerationResponse,
    config: ExportConfig,
    fileName: string
  ): Promise<ExportResult> {
    let csvContent = ''

    // Header
    csvContent += `Parking Management Report\n`
    csvContent += `Report Type,${report.reportType.toUpperCase()}\n`
    csvContent += `Period,${format(report.dateRange.startDate, 'MMMM d yyyy')} - ${format(report.dateRange.endDate, 'MMMM d yyyy')}\n`
    csvContent += `Generated,${format(report.generatedAt, 'MMMM d yyyy \'at\' h:mm a')}\n`
    csvContent += `\n`

    // Report-specific CSV content
    switch (report.reportType) {
      case 'daily':
        csvContent += this.prepareDailyCSVContent(report.data as DailyReportContent, config)
        break
      case 'weekly':
        csvContent += this.prepareWeeklyCSVContent(report.data as WeeklyReportContent, config)
        break
      case 'monthly':
        csvContent += this.prepareMonthlyCSVContent(report.data as MonthlyReportContent, config)
        break
      case 'custom':
        csvContent += this.prepareCustomCSVContent(report.data as CustomReportContent, config)
        break
    }

    // Create blob and download link
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
    const downloadLink = URL.createObjectURL(blob)

    return {
      success: true,
      fileName,
      downloadLink
    }
  }

  private prepareDailyCSVContent(data: DailyReportContent, config: ExportConfig): string {
    let content = ''

    // Summary
    content += `Daily Summary\n`
    content += `Metric,Value\n`
    content += `Total Sessions,${data.totalSessions ?? 0}\n`
    content += `Active Sessions,${data.activeSessions ?? 0}\n`
    content += `Completed Sessions,${data.completedSessions ?? 0}\n`
    content += `Revenue,$${(data.revenue ?? 0).toFixed(2)}\n`
    content += `Expenses,$${(data.expenses ?? 0).toFixed(2)}\n`
    content += `Net Income,$${(data.netIncome ?? 0).toFixed(2)}\n`
    content += `\n`

    // Hourly breakdown
    if (config.includeHourlyBreakdown && data.hourlyBreakdown?.length > 0) {
      content += `Hourly Breakdown\n`
      content += `Hour,Entries,Exits,Revenue,Occupancy\n`
      data.hourlyBreakdown.forEach(hour => {
        content += `${hour?.hour ?? 0}:00,${hour?.entries ?? 0},${hour?.exits ?? 0},$${(hour?.revenue ?? 0).toFixed(2)},${hour?.occupancy ?? 0}\n`
      })
      content += `\n`
    }

    // Vehicle type breakdown
    if (data.vehicleTypeBreakdown?.length > 0) {
      content += `Vehicle Type Breakdown\n`
      content += `Vehicle Type,Count,Percentage,Revenue,Avg Stay Duration\n`
      data.vehicleTypeBreakdown.forEach(type => {
        content += `${type?.vehicleType ?? 'Unknown'},${type?.count ?? 0},${(type?.percentage ?? 0).toFixed(1)}%,$${(type?.revenue ?? 0).toFixed(2)},${(type?.averageStayDuration ?? 0).toFixed(1)}h\n`
      })
      content += `\n`
    }

    return content
  }

  private prepareWeeklyCSVContent(data: WeeklyReportContent, config: ExportConfig): string {
    let content = ''

    // Weekly summary
    content += `Weekly Summary\n`
    content += `Metric,Value\n`
    content += `Total Sessions,${data.weeklyTotals?.totalSessions ?? 0}\n`
    content += `Total Revenue,$${(data.weeklyTotals?.totalRevenue ?? 0).toFixed(2)}\n`
    content += `Total Expenses,$${(data.weeklyTotals?.totalExpenses ?? 0).toFixed(2)}\n`
    content += `Net Income,$${(data.weeklyTotals?.netIncome ?? 0).toFixed(2)}\n`
    content += `Average Occupancy,${(data.weeklyTotals?.averageOccupancy ?? 0).toFixed(1)}%\n`
    content += `\n`

    // Daily breakdown
    if (config.includeDailyBreakdown && data.dailyBreakdown?.length > 0) {
      content += `Daily Breakdown\n`
      content += `Date,Total Sessions,Active Sessions,Completed Sessions,Revenue,Expenses,Net Income\n`
      data.dailyBreakdown.forEach(day => {
        content += `${day?.date ?? ''},${day?.totalSessions ?? 0},${day?.activeSessions ?? 0},${day?.completedSessions ?? 0},$${(day?.revenue ?? 0).toFixed(2)},$${(day?.expenses ?? 0).toFixed(2)},$${(day?.netIncome ?? 0).toFixed(2)}\n`
      })
      content += `\n`
    }

    return content
  }

  private prepareMonthlyCSVContent(data: MonthlyReportContent, config: ExportConfig): string {
    let content = ''

    // Monthly summary
    content += `Monthly Summary\n`
    content += `Metric,Value\n`
    content += `Total Sessions,${data.monthlyTotals?.totalSessions ?? 0}\n`
    content += `Total Revenue,$${(data.monthlyTotals?.totalRevenue ?? 0).toFixed(2)}\n`
    content += `Total Expenses,$${(data.monthlyTotals?.totalExpenses ?? 0).toFixed(2)}\n`
    content += `Net Income,$${(data.monthlyTotals?.netIncome ?? 0).toFixed(2)}\n`
    content += `Working Days,${data.monthlyTotals?.totalWorkingDays ?? 0}\n`
    content += `\n`

    // Best performing days
    if (data.bestPerformingDays?.length > 0) {
      content += `Best Performing Days\n`
      content += `Date,Sessions,Revenue,Occupancy Rate\n`
      data.bestPerformingDays.forEach(day => {
        content += `${day?.date ?? ''},${day?.sessions ?? 0},$${(day?.revenue ?? 0).toFixed(2)},${(day?.occupancyRate ?? 0).toFixed(1)}%\n`
      })
      content += `\n`
    }

    return content
  }

  private prepareCustomCSVContent(data: CustomReportContent, config: ExportConfig): string {
    let content = ''

    // Summary
    content += `Custom Report Summary\n`
    content += `Metric,Value\n`
    content += `Period,${data.startDate ?? ''} to ${data.endDate ?? ''}\n`
    content += `Total Days,${data.totalDays ?? 0}\n`
    content += `Total Sessions,${data.summary?.totalSessions ?? 0}\n`
    content += `Total Revenue,$${(data.summary?.totalRevenue ?? 0).toFixed(2)}\n`
    content += `Net Income,$${(data.summary?.netIncome ?? 0).toFixed(2)}\n`
    content += `Average Stay Duration,${(data.summary?.averageStayDuration ?? 0).toFixed(1)}h\n`
    content += `Average Revenue per Session,$${(data.summary?.averageRevenuePerSession ?? 0).toFixed(2)}\n`
    content += `Top Vehicle Type,${data.summary?.topVehicleType ?? 'N/A'}\n`
    content += `Top Payment Method,${data.summary?.topPaymentMethod ?? 'N/A'}\n`

    return content
  }
}

export const reportExportService = new ReportExportService()
export default reportExportService